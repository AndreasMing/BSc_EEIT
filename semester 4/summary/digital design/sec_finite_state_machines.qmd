# Finite State Machines (FSM)

Eine Zustandsmaschine beschreibt ein System in diskreten Zuständen. In **VHDL** wird für Mealy- & Moore-Automaten jeweils ein [*memoryless*]{.underline} und ein [*memorizing*]{.underline} Prozess verwendet. Der [*memoryless*]{.underline} Prozess verarbeitet die Zustandswechsel und die Ausgänge (wobei dies Abhängig vom FSM-Typ ist). Der [*memorizing*]{.underline} Prozess ist für die Zustands-Zurücksetzung und -zuweisung zuständig.

::: callout-note
## Allgemeine Definition ZSM

```{=latex}
\begin{align*}
o[k] = g(i[k], s[k]) \\
s[k+1] = f(i[k], s[k])
\end{align*}

\begin{conditions}
  k & diskrete Zeit mit $t = k\cdot T_{CLK}$, $k=0$ entspricht Reset-Zeitpunkt \\
  s & Zustand des Systems mit $s\in S =\{S_0,S_1,\dots S_N\}$ \\
  i & Input des Systems mit $i\in I =\{I_0,I_1,\dots I_M\}$ \\
  o & Output des Systems mit $o\in O =\{O_0,O_1,\dots, O_K\}$ \\
  g & Output Funktion, berechnet aktuellen Output des Systems \\
  f & Next-State Funktion, berechnet nächsten Zustand des Systems
\end{conditions}
```
:::

## FSM-Typ: Mealy

![](images/fsm_mealy.png){fig-align="center" width="4cm"}

```{=latex}
\begin{align*}
o[k] = g(i[k], s[k]) \\
s[k+1] = f(i[k], s[k])
\end{align*}
```
Beim *Mealy* werden die Ausgänge [beim Zustandswechsel]{.underline} geändert.

## FSM-Typ: Moore

![](images/fsm_moore.png){fig-align="center" width="5.5cm"}

```{=latex}
\begin{align*}
o[k] = g(s[k]) \\
s[k+1] = f(i[k], s[k])
\end{align*}
```
Beim *Moore* werden die Ausgänge [im Zustand]{.underline} geändert.

::: callout-caution
## Unterschied Mealy- & Moore-Outputs

Eine Mealy-FSM ändert den Ausgang [beim]{.underline} Zustandswechsels, was einen [*0-Delay*]{.underline} einführt. Eine Moore-FSM verändert den Ausgang [im]{.underline} Zustand, was einen [*1-Delay*]{.underline} einführt.

![Mealy](images/fsm_output_delay_mealy.png){fig-align="center" width="8cm" height="3.2cm"}

![Moore](images/fsm_output_delay_moore.png){fig-align="center" width="8cm" height="3.3cm"}
:::

## FSM-Typ: Medvedev

*Medvedev* hat eine ähnlichen Aufbau wie *Moore*, wobei der Ausgang direkt dem Zustandswert entspricht und keine Zwischen-Konvertierung gemacht wird.

```{=latex}
\begin{align*}
o[k] = s[k] \\
s[k+1] = f(i[k], s[k])
\end{align*}
```
## Parasitäre Zustände

Jedes weitere Zustands-Flip-Flop erweitert die Anzahl Faktoren um den Faktor 2 ($S = 2^N$). Ungebrauchte Zustände werden *parasitäre Zustände* genannt.

$$
n_{para}=2^N - S \qquad n_{para}\big\rvert_{S=3,N=2}=2^2-3=1
$$

Folgende Formel kann die Anzahl benötigten Flip-Flops berechnen

$$
N = \left\lceil \log_2(S) \right\rceil = \left\lceil \frac{\log(S)}{\log(2)} \right\rceil \qquad N\big\rvert_{S=3}=\left\lceil\log_2(5)\right\rceil = 3
$$

```{=latex}
\begin{conditions}
  N & Anzahl Flip-Flops \\
  S & Anzahl verwendete Zustände
\end{conditions}
```

## State Encoding

Zustände können auf verschiedene Arten dargestellt werden, bekannte Varianten sind *binär* und *One Hot*.

```{=latex}
\begin{center}
\begin{tabularx}{\linewidth}{|l|c|c|}
\hline
\textbf{Zustand}                          & \multicolumn{1}{l|}{\textbf{Binär}} & \multicolumn{1}{l|}{\textbf{One-Hot}} \\ \hline
$S_0$                                     & \texttt{00}                         & \texttt{001} \\ \hline
$S_1$                                     & \texttt{01}                         & \texttt{010} \\ \hline
$S_2$                                     & \texttt{10}                         & \texttt{100} \\ \hline
\textcolor{BrickRed}{Parasitäre Zustände} & \textcolor{BrickRed}{\texttt{11}}   & \textcolor{BrickRed}{\texttt{000}}, 
                                                                                  \textcolor{BrickRed}{\texttt{011}}, 
                                                                                  \textcolor{BrickRed}{\texttt{111}}, 
                                                                                  \textcolor{BrickRed}{\texttt{110}}, 
                                                                                  \textcolor{BrickRed}{\texttt{101}} \\ \hline

\end{tabularx}
\end{center}
```

::: callout-warning
## Parasitäre Zustände

Alle **ungebrauchten** Zustände sind *parasitäre Zustände*!
:::

### Binär

Meistverwendetes Format ist *binär*, da es **kompakt** und **einfach erweiterbar** ist.

-   $S_0\ \rightarrow$ `0000`

-   $S_1\ \rightarrow$ `0001`

-   $S_2\ \rightarrow$ `0010`

### One-Hot

Bei *One-Hot* ist **ein Bit** *high* und **alle anderen Bits** *low* oder in anderen Worten, nur ein Bit ist aktiv.

## Goldene Regeln der (FSM) Implementierung

-   Memoryless Process (kombinatorische Logik)

    -   Alle Eingangssignale der FSM und der aktuelle Zustand müssen in der *sensitivity list* aufgeführt werden.

    -   [Jedem]{.underline} Ausgangssignal muss für [jede]{.underline} mögliche Kombination von Eingangswerten (inkl. parasitäre Input-Symbole) ein Wert zugewiesen werden. **Keine Zuweisung bedeutet sequentielles Verhalten (Speicher)!**

    -   Parasitäre Zustände sollten mittels `others` abgefangen werden.

-   Memorizing Process (sequentielle Logik)

    -   Ausser Clock und (asynchronem) Reset dürfen [keine]{.underline} Signale in die *sensitivity list* aufgenommen werden.

    -   Das den Zustand repräsentierende Signal muss einen Reset-Wert erhalten.