# VHDL

::: callout-note
**V**ery High Speed Integrated Circuit **H**ardware **D**escription **L**anguage ist einer Hardwarebeschreibung und [keine]{.underline} Programmiersprache.
:::

## Entwicklung

### Designflow

![](images/vhdl_fpga_designflow.png){width="14cm"}

### Struktur Datei

``` vhdl
-- File: MyComponent.vhd
-- Author: myself
-- Date: yesterday

library ...
-- Library einbinden
use ...
-- Packages aus Library bekanntgeben

entity ...
-- Schnittstelle der Komponente gegen aussen

architecture ...
-- Funktion (Innenleben) der Komponente
```

## Synthesis & Simulation

::: callout-important
### Synthesis vs. Implementation

-   *Synthesis* generiert die Netlist des VHDL-Codes und beschreibt.
-   *Implementation* wendet die Contraints an und sorgt für die Hardware-Implementierung.
:::

### Transactions

### Propagation Delay

## Architektur

Architecture beschreibt die Implementation oder das Innenleben des Komponents. Darin wird beschrieben, wie die deklarierten Signalen miteinander interagieren.

``` vhdl
architecture a1 of MyComponent is
  -- Deklarationen (Signale, Komponenten)
  signal tmp : std_logic;
begin
  -- Implementierung
  tmp  <= a_pi or b_pi;
  c_po <= tmp;
end a1;
```

-   Der **Deklarationsteil** startet [vor]{.underline} dem `begin`
-   Der **Implementierungsteil** startet nach `begin` und endet vor `end`

::: callout-note
#### `rtl` & `struct`

Der Name `rtl` wird verwendet, um grundlegende Logik-Komponenten zu definieren, wie zum Beispiel *OR*, *XOR*, *AND*, etc. `struct` beinhaltet eine Kombination/Anwendung von `rtl`-Komponenten.
:::

## Entity

Eine Entity beschreibt den Komponenten für äusserliche Zugriffe. Es wird nur die Struktur des Komponents bekannt gegeben, aber nicht den Inhalt des Komponenten.

``` vhdl
entity MyComponent is
  port ( a_pi, b_pi : in std_logic;
        -- Input Ports
        c_po : out std_logic
        -- Output Port
        --x_pio : inout std_logic
        -- Bidirektionaler Port
       );
  constant c_max_cnt : integer := 20_000;
end MyComponent;
```

::: callout-note
Alles was in der Entity bekannt ist (inkl. Libraries), ist auch in der zugehörigen Architecture bekannt.
:::

## Components

## Kombinatorische Logik

Folgend sind *Process Statements* in Kurzschreibweise - Concurrent Signal Assignments - Selected Signal Assignment - Conditional Signal Assignment

::: callout-important
## Process Statements

Alle Signal Assignments ausserhalb von `process` (Concurrent-, Selected-, Conditional-Signal Assignment) sind **Process Statements** in Kurzschreibform!

``` vhdl
sig <= not sig; -- Process Statement
stud <= happy     when mep >= C else
        satisfied when mep >= E else
        sad;    -- Process Statement
```
:::

### Concurrent Signal Assignments

### Selected Signal Assignments `case`

### Conditional Signal Assignments `when/else`

## Prozesse/Sequential Statements

``` vhdl
-- process sensitivity list
P1: process (i1, i2, i3)

-- local variable (only known in P1)
variable v_tmp : std_logic;
begin
  v_tmp := ’0’;
  if i1 = ’1’ and i2 = ’0’ then v_tmp := ’1’; end if;
  o1 <= v_tmp and i3;
-- process P1 drives signal o1
  o2 <= v_tmp xor i3;
-- process P1 drives signal o2
end process P1;
```

### Sensitivity List

Prozesse werden mit Hilfe einer *Sensitivity List* auf ausgewählte Signale [sensitiv]{.underline} gemacht.

## Grundlegende Konzepte

### Ports & Signale

Port sind die Anschlüsse eines Komponents und Signale sind Komponent-interne Signale, welche von aussen nicht zugreifbar sind.

<!-- TODO -->

`std_logic`, `std_ulogic`, `std_logic_vector(a downto b)`

### Treiber `<=`

Der Treiber `<=` beschreibt, dass das linke Signal vom rechten Signal angetrieben wird. Folgendes Beispiel beschreibt einen Inverter:

``` vhdl
Inv_Out <= not Inv_In;
```

# VHDL Syntax

``` vhdl
y <= (0 => '0', 1 => '0', 2 => '0', 3 => '0');
y <= (others => '0');
y <= "0000";
```

Conditional Signal Assignment

``` vhdl
y <= x when en = '1' else "0000";
y <= x when en = '1' else (others => '0');
```

Prozess Statement with sequential loop-Statement

``` vhdl
process(x,en)
begin
  for k in 3 downto 0 loop
    y(k) <= x(k) and en;
  end loop;
end process;
```