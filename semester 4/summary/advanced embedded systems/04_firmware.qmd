# Firmware

## Architektur

Firmware benötigt je nach Anwendung selbst eine Code-Architektur, welche die Art, wie Jobs ausgeführt werden, definiert. Welcher Loop verwendet wird, ist von verschiedenen Kriterien wie Grösse, Komplexität, Funktionalität, Anzahl Aufgaben, Anforderungen, Wartbarkeit, Erweiterbarkeit, wenige Ressourcen, usw. abhängig.

### Super Loop

![](images/firmware_super_loop.png){fig-align="center" width="14cm"}

Beim *Super Loop* werden alle Arbeiten [nacheinander]{.underline} erledigt und gehört zu den einfachen Ansätzen. Diese Art ist ebenfalls gut wartbar.

1.  Initialisierung Hardware & Gerätetreiber
2.  Unendlicher Loop welcher die Arbeiten nacheinander ausführt.

[Beispiel]{.underline}

``` cpp
void main(void) {
  InitHardware ();
  InitDrivers ();
  for (;;) {
    DoJob1 ();
    DoJob2 ();
    /* ... */
    DoJobN ();
  } /* forever */
}
```

::: callout-note
## Herausforderung

Eine Problematik, welche dieser Ansatz bringt, ist, wenn Arbeiten oder Jobs länger brauchen und somit andere verzögern. Besonders ist es ein **Problem**, wenn die **Verzögerungen variable** sind und sich **je nach Situation unterscheiden**.
:::

::: callout-tip
## Finite State Machine (FSM)

Eine Lösung zu diesem Problem ist, dass eine FSM verwendet wird, welche die Schritte der einzelnen Jobs aufteilet und somit die Latenz zwischen den Jobs verkürzt. Dies macht aber die Implementation der Zustände und Abarbeitung komplexer.

``` cpp
for (;;) {
  DoJob1_part1 (); /* split Job1 into smaller parts */
  DoJob2 ();
  DoJob1_part2 (); /* split Job1 into smaller parts */
  DoJob3 ();
  DoJob1_part3 (); /* split Job1 into smaller parts */
  /* ... */
  DoJobN ();
} /* forever */
```
:::

### Event Loop

![](images/firmware_event_loop.png){fig-align="center" width="14cm"}

Bei einem *Event Loop* werden Ereignisse/(Hardware) Interrupts verwendet, um Arbeiten zu veranlassen. Diese Art macht den Ablauf **ereignisgesteuert** und reduziert somit die Latenz der Jobs, da diese nur ausgeführt werden, wenn es nötig ist.

Der grösste Vorteil von diesem Ansatz ist es, dass der Main Loop in einem stromsparenden Modus gehen kann und später durch einen Event oder Interrupt wieder aufgeweckt werden kann.

[Beispiel]{.underline}

``` cpp
void ButtonInterrupt (void) {
  QueueEvent( Button_Pressed );
}

void main(void) {
  InitHardware();
  InitDriversAndInterrupts();
  for (;;) { /* smaller loop */
    GoToSleep(); /* wait for event */
    ProcessQueues();
  } /* forever */
}
```

::: callout-note
## Herausforderung

FSM oder Jobs sollten nicht direkt in den Interrupts ausgeführt werden, da dies andere Interrupts blockieren kann und Latenz einführt oder durch einen höher priorisierten Interrupt unterbrochen werden.

-   Für **kleine Jobs** kann dies direkt **im Interrupt-Event** ausgeführt werden.

-   Für **alle anderen Jobs** sollte eine ***Queue*** oder einen Benachrichtigungsmechanismus wie den ***Dispatcher*** verwendet werden.
:::

::: callout-tip
## Mischform

Es gibt auch Mischformen von *Super Loops* und *Event Loops*, welche eine Balance zwischen Komplexität und Latenzzeit erreicht.
:::

### Embedded OS

![](images/firmware_os_loop.png){fig-align="center" width="14cm"}

Ein *Embedded OS* sind für Mikrocontroller oder kleine Computer ausgelegt und arbeitet mit **Threads**. Jobs werden in Threads verteilt und das Betriebsystem (*OS*) verwaltet die Ausführung der Threads. Dies bringt grosse Erweiterbarkeit und Flexibilität.

``` cpp
void mainTask(void) {
  CreateTask(sensorTask);
  CreateTask(otherTask);
  /* ... */
  for (;;) {
    /* do work */
  }
}

void main(void) {
  InitHardware();
  InitDriversAndInterrupts();
  CreateTask(mainTask);
  StartOS();
}
```

Vorteil dieses Ansatzes ist, dass jeder Job für sich arbeitet und Zugriff zur Hardware hat. Die Jobs arbeiten "parallel" miteinander.

::: callout-note
## Herausforderung

Eine Herauserforderung ist die Art, wie die Tasks beim OS-*Scheduler* "angemeldet" werden. Eine Alternative zu *Main Task erstellt alle anderen Tasks*, da dieser bei Resourcenmangel zu einem Abbruch des Systems führen kann, ist, dass alle Tasks vor dem Start des OS-*Scheduler* erstellt werden.
:::

## Modularisierung

# Module

## Anforderungen

-   **Interface** --

-   **Synchronisation** --

-   **Organisation** --

-   **Konfiguration** --

-   **Funktionaliät**, **Init** und **Deinit** --