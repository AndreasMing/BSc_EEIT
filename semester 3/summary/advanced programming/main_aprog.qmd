---
title: "Zusammenfassung Advanced Programming"
author: "Joel von Rotz & Andreas Ming"
date: "19.06.1932"

lang: de

format:
  pdf:
    include-in-header:
      - config.tex
    keep-tex: true
geometry: 
- "top=25mm"
- "bottom=30mm"
- "left=15mm"
- "right=15mm"
papersize: a4paper
fontsize: 10pt

toc: true
toc-depth: 3
number-sections: true
number-depth: 3

pdf-engine: pdflatex
pagenumbering: none

highlight-style: github
---

# C-Sharp Begriffe

## Dictionary - `Dictionary<TKey,TValue> Class`







# Vergleich `C` & `C#`

- Jede Funktion muss zu einer Klasse gehören. Es gibt keine ["nackten"]{.underline} Funktionen


# Begriffe

## Namespace

```csharp
namespace { ... }
```

`namespace` dient zur Kapselung von Methoden, Klassen, etc., damit zum Beispiel mehrere Klassen/Methoden gleich benannt werden können.

```csharp
namespace SampleNamespace {
  class SampleClass {...}
  struct SampleStruct {...}
  enum SampleEnum {a, b}
  namespace Nested {
    class SampleClass {...}
  }
}

namespace NameOfSpace {
  class SampleClass{...}
  ...
}
```

## using

`using` wird zum Abkürzen von Namen

```csharp
System.Console.WriteLine("Hello World!");

// using Namespace
using System;
...
Console.WriteLine("Hello World!");
```

## struct & class

::: callout-important
## Unterschied `struct` & `class`

`struct`s sind *value* Typen und übergeben jeden Wert/Eigenschaften. `class`es sind *reference* Typen und werden als Referenz übergeben.

- `class` $\rightarrow$ call by reference (Übergabe als Reference)
- `struct` $\rightarrow$ call by value (Übergabe als Wert)

:::

# Datentypen

## String

Strings werden mit dem folgender Deklaration 

::: callout-important

Strings können nicht verändert werden -> sind **read-only**

```csharp
string s = "Hallo Welt";

s[1] = 'A'; // ERROR
```

:::

### Parameter in String einfügen

Parameter/variablen können in Strings direkt eingefügt werden.


### Bildschirmausgabe

**Variante 1** - C Style:

`Console.WriteLine("The sum of {0} and {1} is {2}",a,b,result);`{.csharp}

**Variante 2** - C# Style:

`Console.WriteLine("The sum of" + a + "and" + b + "is" + result);`{.csharp}

**Variante 3** - new C# Style:

`Console.WriteLine($"The sum of {a} and {b} is {result}");`{.csharp}

# Overloading

## Konstruktor Overloading

```csharp
class Point {
  private int pos_x;
  private int pos_y;

  public Point(int x, int y) {
    this.pos_x = x;
    this.pos_y = y;
  }

  public Point() : this(0,0) {}
}
```

Mit `this` nach dem Konstruktor (unterteilt mit `:`) kann der Aufruf auf einen anderen Konstruktor weitergeleitet werden. Der Inhalt des vorherigen Konstruktors wird erst nach dem Ablauf des `this`-Konstruktors (im Beispiel `Point(int x, int y)`).

### Konstruktor Aufruf-Reihenfolge

```csharp
using System;

class Point {
  private int pos_x;
  private int pos_y;

  public Point(int x, int y) {
    this.pos_x = x;
    this.pos_y = y;
    Console.WriteLine($"Point {this.pos_x}, {this.pos_y}");
  }

  public Point(int x) : this(x, 0) {
    Console.WriteLine("x-only");
  }

  public Point() : this(0,0) {}
  Console.WriteLine("no value");
}
```

Wird nun `Point(4)` aufgerufen erhält man folgendes auf der Konsole

```output
Point 4, 0
x-only
```

## Default Parameter (implizit Overloading)

```csharp

```

# Funktion


## `out` 

```csharp

```

# Notes

## Overflows Integer

Im folgenden Code wird eine Variable `i` mit dem maximalen Wert eines `int` geladen und folgend inkrementiert.

```csharp
int i = int.MaxValue;
i++;
```

Wird aber dies direkt in der Initialisierung eingebettet (`...+ 1`), ruft der Compiler aus, da er den Overflow erkennt. (Einsetzung von Compilern)

```csharp
int i = int.MaxValue + 1; // COMPILE-FEHLER
i++;
```

::: callout-caution

Dieser Overflow-Fehler gilt nur bei **konstanten** Werten bei der Initialisierung. Wird eine separate Variable mit dem Maximalwert initialisierit und an `i` hinzuaddiert, gibt es keinen Fehler.


```csharp
int k = int.MaxValue;
int i = k + 1; // KEIN Fehler
```

:::

# Multithreading `System.Threading`

```csharp
static void Main(string[] args) {
  Thread t = new Thread(Run);
  t.Start();
  Console.ReadKey();
}

static void Run() {
  Console.WriteLine("Thread is running...");
}
```

## Parametrisierter Thread

Falls ein Parameter übergeben werden muss, kann die delegierte `ParameterizedThreadStart`-Signatur verwendet werden. Der Thread wird normal aufgesetzt und bei `.Start()`

```csharp
static void Main(string[] args)
{
  //...
  TcpClient client = listener.AcceptTcpClient();
  Thread t = new Thread(HandleDateTimerequest);
  t.Start(client);
  // ...
}

// must be of ParameterizedThreadStart signature
private void HandleDateTimerequest(object _object)
{
  TcpClient client = (TcpClient)_object;
  // ...
}
```

# **W**indows **P**resentation **F**oundation

::: callout-note
## Unterschied zwischen WPF & Console Application

WPF ist 

:::

---

# Glossar

- **Timeslicing**: Bei Computersystemen wird *timeslicing* verwendet, damit mehrere Prozesse "parallel" verlaufen können. Jedem Prozess/Thread wird ein fixer Zeitslot gegeben, in dem es sein Code abarbeiten kann,  

- **Präventiv/kooperativ**: Ein *präventives* Betriebsystem unterbricht ein Prozess, wenn dieser sein Time-Slot verbraucht hat. Ein *kooperatives* BS unterbicht die Prozesse [nicht]{.underline} und die Prozesse geben an, wann es fertig ist. 