---
title: "Zusammenfassung Advanced Programming"
author: "Joel von Rotz & Andreas Ming"
date: "01.01.2023"

lang: de

# [RENDER CONFIGURATION] ==============================
format:
  pdf:
    include-in-header:
      - config.tex
    keep-tex: true

pdf-engine: pdflatex
# [DOCUMENT CONFIGURATION] ============================
geometry: 
- "top=25mm"
- "bottom=30mm"
- "left=15mm"
- "right=15mm"
papersize: a4paper
fontsize: 9pt

code-block-border-left: false
code-block-bg: "#f7f7f7"

toc: true
toc-depth: 3
number-sections: true
number-depth: 3
pagenumbering: none
highlight-style: github
---

# `C#` und `.Net`-Framework

## Vergleich `C` & `C#`

|                 |                      C *(POP)*                     |                   C# *(OOP)*                  |
|:---------------:|:--------------------------------------------------:|:---------------------------------------------:|
|                 | **P**rozedurale **O**rientierte **P**rogrammierung | **O**bjekt **O**rientierte **P**rogrammierung |
|   Compilation   |                     Interpreter                    |              Just-in-time *(CLR)*             |
|    Execution    |                   Cross-Platform                   |                `.Net` Framework               |
| Memory handling |              `free()` after `malloc()`             |               Garbage collector               |
|    Anwendung    |             Embedded, Real-Time-Systeme            | Embedded OS, Windows, Linux, GUIs             |
|  Execution Flow |                      Top-Down                      |                   Bottom-Up                   |
|  Aufteilung in  |                     Funktionen                     |                    Methoden                   |
|   Arbeitet mit  |                     Algorithmen                    |                     Daten                     |
| Datenpersistenz |      Einfache Zugriffsregeln und Sichtbarkeit      | Data Hiding (`privat`, `public`, `protected`) |
|  Lib-Einbindung |              *.h* File mit `#include`              |            *namespaces* mit `using`           |

[]: # (Do more as you'd like. See table "VergleichC.tgn" to use on "https://www.tablesgenerator.com/markdown_tables")

`\begin{multicols}{2}`{=latex}

## Struktur `C#`-Programm

### Namespace

```csharp
namespace { ... }
```

`namespace` dient zur Kapselung von Methoden, Klassen, etc., damit zum Beispiel mehrere Klassen/Methoden gleich benannt werden können.

```csharp
namespace SampleNamespace {
  class SampleClass {...}
  struct SampleStruct {...}
  enum SampleEnum {a, b}
  namespace Nested {
    class SampleClass {...}
  }
}

namespace NameOfSpace {
  class SampleClass{...}
  ...
}
```

Zum Aufrufen von Klassen/Methoden anderer `namespace`'s kann dieser über `using` eingebunden werden oder der Aufruf geschieht über `namespace.SampleClass`.

### Klassen

Klassen beschreiben den Bauplan von Objekten. Wenn man das nicht versteht, nützt dir auch der Rest der Zusammenfassung nichts ;)

### Konstruktor

Konstruktoren werden beim Erstellen von neuen Objekten aufgerufen. Ihnen können Parameter oder andere Objekte übergeben werden.

```{.csharp}
public class Point{
  int size;

  public Point(int size) {
    this.size = size;
  }
}

public Program{
  satic void Main(){

    // initialize new Point object
    Point smallPoint = new Point(2);
  }
}
```

::: callout-tip
 Der Default-Konstruktor nimmt keine Parameter entgegen. Wird ein Konstruktor angegeben, so ist der Default-Konstruktor nichtmehr aufrufbar.
:::

### Destruktor

### Methode

### Membervariable

### Property

## .Net Bibliotheken

### `System`

#### `Sysem.Console`

## Keywords

### Operatoren & Abarbeitungsreihenfolge

### Zugriffs-Modifier

![](images/AccessModifiers.png)

*Modifier* sind auf Klassen, Enum, Membervariablen, Properties und Methoden anwendbar.

### `using`

Die `using`-Direktive teilt dem Compiler mit welcher `namespace` während der Compilierung verwendet werden soll. Wenn `using` nicht verwendet wird, muss bei einem Methodenaufruf auch der entsprechende `namespace` genannt werden.

```csharp
// w/o `using`
System.Console.WriteLine("Hello World!");

// w/ `using`
using System;
...
Console.WriteLine("Hello World!");
```

### `static`

### `const`

### `readonly`

## Datentypen

Wie in C gibt es in C# Wertetypen und Referenztypen

![](images/Types.png)

### `class`


### `struct`

::: callout-important
## Unterschied `struct` & `class`

`struct`s sind *value* Typen und übergeben jeden Wert/Eigenschaften. `class`es sind *reference* Typen und werden als Referenz übergeben.

- `class` $\rightarrow$ call by reference (Übergabe als Reference)
- `struct` $\rightarrow$ call by value (Übergabe als Wert)

:::

### `string`

Strings werden mit dem folgender Deklaration 

::: callout-important

Strings können nicht verändert werden -> sind **read-only**

```csharp
string s = "Hallo Welt";

s[1] = 'A'; // ERROR
```

:::

#### Stringformatierung

Parameter/variablen können in Strings direkt eingefügt werden.

```{.csharp}
// C-Sytle
Console.WriteLine("{0} + {1} = {2}",a,b,res);

// C#-Style
Console.WriteLine(a + " + " + b + " = " + res);

// C# formatted string
Console.WriteLine($"{a} + {b} = {res}");
```

### Enum

### Array


# Konzepte `C#`

## Collections

### Indexer

### Generics

## Scope & Zugriff

## Overloading

::: callout-important
Overloading-Signaturen müssen sich in den **Datentypen** unterscheiden. Unterschiedliche Variabel-Namen führen zu einem *Compiler-Error*.
:::

### Konstruktor Overloading

Je nach Signatur können andere Konstruktoren aufgerufen werden. Dies nennt man auch *Overloading*. In folgendem Beispiel kann ein `Point` Objekt erstellt werden entweder mit oder ohne Angabe der Position.

```csharp
class Point {
  private int pos_x;
  private int pos_y;

  public Point(int x, int y) {
    this.pos_x = x;
    this.pos_y = y;
  }

  public Point() { }
}
```

#### Konstruktor Aufruf-Reihenfolge

Mit `this` nach dem Konstruktor (unterteilt mit `:`) kann der Aufruf auf einen anderen Konstruktor weitergereicht werden.

```csharp
using System;

class Point {
  private int x;
  private int y;

  public Point(int x, int y) {
    this.x = x;
    this.y = y;
    Console.WriteLine($"Point {this.x},{this.y}");
  }

  public Point(int x) : this(x, 0) {
    Console.WriteLine("x-only");
  }

  // Two identical signatures -> ERROR
  public Point(int y) : this(y, 0) {
    Console.WriteLine("y-only");
  }

  public Point() : this(0,0) {}
  Console.WriteLine("no value");
}
```

Wird nun `Point(4)` aufgerufen, werden die Parameter auf die unterste Ebene durchgereicht und die Konstruktoren werden in umgekehrter Aufrufreihenfolge abgearbeitet. So erhält man folgendes auf der Konsole

```output
Point 4,0
x-only
```

### Methoden Overloading

Je nach Signatur können andere Methoden aufgerufen werden. Dies nennt man auch *Overloading*. In folgendem können Flächen mit unterschiedlichen Angaben gerechnet werden.

```csharp
public int Area(int width, int height) {
  return width * height;
}

public int Area(int squareSide) {
  return squareSide^2;
}

public int Area(Point a, Point b) {
  return (a.x - b.x) * (a.y - b.y);
}
```

## Default Parameter

Für Default-Werte können Konstruktoren implizit Überladen werden.

```{.csharp}
public void Draw(bool inColor = true) { ... }

// initialize drawing object
Draw inColor = new Draw();    // inColor = true
Draw bw = new Draw(false);    // inColor = false
```

## Garbage-Collector

## Signatur

## Exceptions

(`try`,`catch`,`finally`, `throw`)

## Multithreading `System.Threading`


```csharp
static void Main(string[] args) {
  Thread t = new Thread(Run);
  t.Start();
  Console.ReadKey();
}

static void Run() {
  Console.WriteLine("Thread is running...");
}
```

### Sync

### Deadlock

### Parametrisierter Thread

Falls ein Parameter übergeben werden muss, kann die delegierte `ParameterizedThreadStart`-Signatur verwendet werden. Der Thread wird normal aufgesetzt und bei `.Start()`

```csharp
static void Main(string[] args)
{
  //...
  TcpClient client = listener.AcceptTcpClient();
  Thread t = new Thread(HandleRequest);
  t.Start(client);
  // ...
}

// must be of ParameterizedThreadStart signature
private void HandleRequest(object _object)
{
  TcpClient client = (TcpClient)_object;
  // ...
}
```

## Boxing & Unboxing

## Streams

## Delegates

### Multicast

## Events

# Vererbung

## Abstrakte Klassen

## Interfaces

## Polymorphismus

## Klassendiagramme

# Linux & Raspberry Pi 4

## Bash-Commands

## Streams

## GPIO via Konsole

## Berechtigungssystem

## Passwort Hashing

## Logfiles & NLog

## Benutzerverwaltung

## SSH

## C# deployment

### Remote-Debugging

## System-Control

### Deamons

## Tunneling

## UART TinyK <-> RBP

# **W**indows **P**resentation **F**oundation

::: callout-note
## Unterschied zwischen WPF & Console Application

WPF ist 

:::

## Dispatcher

## Key-Event

# Weitere Konzepte

## TCP / UDP

## MQTT

## Unit Tests

# Notes

## Overflows Integer

Im folgenden Code wird eine Variable `i` mit dem maximalen Wert eines `int` geladen und folgend inkrementiert.

```csharp
int i = int.MaxValue;
i++;
```

Wird aber dies direkt in der Initialisierung eingebettet (`...+ 1`), ruft der Compiler aus, da er den Overflow erkennt. (Einsetzung von Compilern)

```csharp
int i = int.MaxValue + 1; // COMPILE-FEHLER
i++;
```

::: callout-caution

Dieser Overflow-Fehler gilt nur bei **konstanten** Werten bei der Initialisierung. Wird eine separate Variable mit dem Maximalwert initialisierit und an `i` hinzuaddiert, gibt es keinen Fehler.


```csharp
int k = int.MaxValue;
int i = k + 1; // KEIN Fehler
```

:::

`\end{multicols}`{=latex}



# Glossar

- **Timeslicing**: Bei Computersystemen wird *timeslicing* verwendet, damit mehrere Prozesse "parallel" verlaufen können. Jedem Prozess/Thread wird ein fixer Zeitslot gegeben, in dem es sein Code abarbeiten kann,  

- **Präventiv/kooperativ**: Ein *präventives* Betriebsystem unterbricht ein Prozess, wenn dieser sein Time-Slot verbraucht hat. Ein *kooperatives* BS unterbicht die Prozesse [nicht]{.underline} und die Prozesse geben an, wann es fertig ist. 