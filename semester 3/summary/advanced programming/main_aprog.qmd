---
title: "Zusammenfassung Advanced Programming"
author: "Joel von Rotz & Andreas Ming"
date: "01.01.2023"

lang: de

# [RENDER CONFIGURATION] ==============================
format:
  pdf:
    include-in-header:
      - config.tex
    keep-tex: true

pdf-engine: pdflatex

# [DOCUMENT CONFIGURATION] ============================
geometry: 
- "top=25mm"
- "bottom=30mm"
- "left=15mm"
- "right=15mm"
papersize: a4paper
fontsize: 10pt

code-block-border-left: false
code-block-bg: "#f7f7f7"

toc: true
toc-depth: 3
number-sections: true
number-depth: 3
pagenumbering: none
highlight-style: github
---

# `C#` und `.Net`-Framework

## Vergleich `C` & `C#`

|                 |                      C *(POP)*                     |                   C# *(OOP)*                  |
|:---------------:|:--------------------------------------------------:|:---------------------------------------------:|
|                 | **P**rozedurale **O**rientierte **P**rogrammierung | **O**bjekt **O**rientierte **P**rogrammierung |
|   Compilation   |                     Interpreter                    |              Just-in-time *(CLR)*             |
|    Execution    |                   Cross-Platform                   |                `.Net` Framework               |
| Memory handling |              `free()` after `malloc()`             |               Garbage collector               |
|    Anwendung    |             Embedded, Real-Time-Systeme            | Embedded OS, Windows, Linux, GUIs             |
|  Execution Flow |                      Top-Down                      |                   Bottom-Up                   |
|  Aufteilung in  |                     Funktionen                     |                    Methoden                   |
|   Arbeitet mit  |                     Algorithmen                    |                     Daten                     |
| Datenpersistenz |      Einfache Zugriffsregeln und Sichtbarkeit      | Data Hiding (`privat`, `public`, `protected`) |
|  Lib-Einbindung |              *.h* File mit `#include`              |            *namespaces* mit `using`           |

[]: # (Do more as you'd like. See table "VergleichC.tgn" to use on "https://www.tablesgenerator.com/markdown_tables")

`\begin{multicols}{2}`{=latex}
## Struktur `C#`-Programm

### Klassen

### Namespace

```csharp
namespace { ... }
```

`namespace` dient zur Kapselung von Methoden, Klassen, etc., damit zum Beispiel mehrere Klassen/Methoden gleich benannt werden können.

```csharp
namespace SampleNamespace {
  class SampleClass {...}
  struct SampleStruct {...}
  enum SampleEnum {a, b}
  namespace Nested {
    class SampleClass {...}
  }
}

namespace NameOfSpace {
  class SampleClass{...}
  ...
}
```

## Keywords

### Zugriffs-Modifier

* `public`
* `protected`
* `protected internal`
* `private protected`
* `internal`
* `private`

### `using`

`using` wird zum Abkürzen von Namen

```csharp
System.Console.WriteLine("Hello World!");

// using Namespace
using System;
...
Console.WriteLine("Hello World!");
```

### `class`

### `struct`

::: callout-important
## Unterschied `struct` & `class`

`struct`s sind *value* Typen und übergeben jeden Wert/Eigenschaften. `class`es sind *reference* Typen und werden als Referenz übergeben.

- `class` $\rightarrow$ call by reference (Übergabe als Reference)
- `struct` $\rightarrow$ call by value (Übergabe als Wert)

:::

## Datentypen

### `string`

Strings werden mit dem folgender Deklaration 

::: callout-important

Strings können nicht verändert werden -> sind **read-only**

```csharp
string s = "Hallo Welt";

s[1] = 'A'; // ERROR
```

:::

#### Parameter in String einfügen

Parameter/variablen können in Strings direkt eingefügt werden.


### Konsolenausgabe

**Variante 1** - C Style:

`Console.WriteLine("{0} + {1} = {2}",a,b,res);`{.csharp}

**Variante 2** - C# Style:

`Console.WriteLine(a + " + " + b + " = " + res);`{.csharp}

**Variante 3** - new C# Style:

`Console.WriteLine($"{a} + {b} = {res}");`{.csharp}

# Konzepte `C#`
## Overloading

### Konstruktor Overloading

```csharp
class Point {
  private int pos_x;
  private int pos_y;

  public Point(int x, int y) {
    this.pos_x = x;
    this.pos_y = y;
  }

  public Point() : this(0,0) {}
}
```

Mit `this` nach dem Konstruktor (unterteilt mit `:`) kann der Aufruf auf einen anderen Konstruktor weitergeleitet werden. Der Inhalt des vorherigen Konstruktors wird erst nach dem Ablauf des `this`-Konstruktors (im Beispiel `Point(int x, int y)`).

#### Konstruktor Aufruf-Reihenfolge

```csharp
using System;

class Point {
  private int pos_x;
  private int pos_y;

  public Point(int x, int y) {
    this.pos_x = x;
    this.pos_y = y;
    Console.WriteLine($"Point "+
                      $"{pos_x},{pos_y}");
  }

  public Point(int x) : this(x, 0) {
    Console.WriteLine("x-only");
  }

  // Two identical signatures -> ERROR
  public Point(int y) : this(y, 0) {
    Console.WriteLine("y-only");
  }

  public Point() : this(0,0) {}
  Console.WriteLine("no value");
}
```

Wird nun `Point(4)` aufgerufen erhält man folgendes auf der Konsole

```output
Point 4,0
x-only
```

### Methoden Overloading

## Default Parameter (implizit Overloading)

## Multithreading `System.Threading`

```csharp
static void Main(string[] args) {
  Thread t = new Thread(Run);
  t.Start();
  Console.ReadKey();
}

static void Run() {
  Console.WriteLine("Thread is running...");
}
```

## Parametrisierter Thread

Falls ein Parameter übergeben werden muss, kann die delegierte `ParameterizedThreadStart`-Signatur verwendet werden. Der Thread wird normal aufgesetzt und bei `.Start()`

```csharp
static void Main(string[] args)
{
  //...
  TcpClient client = listener.AcceptTcpClient();
  Thread t = new Thread(HandleDateTimerequest);
  t.Start(client);
  // ...
}

// must be of ParameterizedThreadStart signature
private void HandleDateTimerequest(object _object)
{
  TcpClient client = (TcpClient)_object;
  // ...
}
```

# Linux & Raspberry Pi 4

# **W**indows **P**resentation **F**oundation

::: callout-note
## Unterschied zwischen WPF & Console Application

WPF ist 

:::

---

# Weitere Konzepte

## TCP / UDP

## MQTT

# Notes

## Overflows Integer

Im folgenden Code wird eine Variable `i` mit dem maximalen Wert eines `int` geladen und folgend inkrementiert.

```csharp
int i = int.MaxValue;
i++;
```

Wird aber dies direkt in der Initialisierung eingebettet (`...+ 1`), ruft der Compiler aus, da er den Overflow erkennt. (Einsetzung von Compilern)

```csharp
int i = int.MaxValue + 1; // COMPILE-FEHLER
i++;
```

::: callout-caution

Dieser Overflow-Fehler gilt nur bei **konstanten** Werten bei der Initialisierung. Wird eine separate Variable mit dem Maximalwert initialisierit und an `i` hinzuaddiert, gibt es keinen Fehler.


```csharp
int k = int.MaxValue;
int i = k + 1; // KEIN Fehler
```

:::

`\end{multicols}`{=latex}



# Glossar

- **Timeslicing**: Bei Computersystemen wird *timeslicing* verwendet, damit mehrere Prozesse "parallel" verlaufen können. Jedem Prozess/Thread wird ein fixer Zeitslot gegeben, in dem es sein Code abarbeiten kann,  

- **Präventiv/kooperativ**: Ein *präventives* Betriebsystem unterbricht ein Prozess, wenn dieser sein Time-Slot verbraucht hat. Ein *kooperatives* BS unterbicht die Prozesse [nicht]{.underline} und die Prozesse geben an, wann es fertig ist. 