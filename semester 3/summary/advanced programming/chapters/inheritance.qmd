Bei der Vererbung wird eine Klasse als **Erweiterung** einer anderen (*Basis*-)Klasse definiert. Die **Basis**klasse beinhaltet die [gemeinsamen]{.underline} Eigenschaften von Klassen und die Erweiterung hat direkten Zugriff auf diese, solange diese [nicht]{.underline} `private` sind.

Vererbungen werden mit dem Schlüsselwort `:` direkt nach dem Klassennamen angegeben. Als Vererbungen können Interfaces, abstrakte und normale Klassen verwendet werden.

::: callout-important
Klassen können nur von **einer** Klasse (inkl. abstrakt) erben, dafür von **mehreren** Interfaces.
:::

```csharp
class Shape {
  protected int x;
  private int ID;
  //...
}

class Circle : Shape {
  public Circle(int x) {
    this.x = x;
    this.ID = ...; // ERROR: no direct access
  }
}
```

Basisklasse-Konstruktoren **mit** Parametern, müssen in dem erbenden Klassenkonstruktor mit dem Schlüsselwort `base` ausgeführt werden (mit einem Doppelpunkt `:` dazwischen).

```csharp
class Shape {
  protected Shape(int x, int y) { /* ... */ }
}

class Circle : Shape {
  public Circle() : base(0,0) { /* ... */ }
}
```

## Abstrakte Klassen

### virtual

Das Schlüsselwort `virtual` wird verwendet, um Methoden-, Eigenschaften-, Indexer- oder Ereignisdeklarationen zu ändern und erlaubt es abgeleiteten Klassen, diese zu überschreiben. Wenn eine `virtual` Methode aufgerufen wird, wird der Laufzeittyp des Objekts auf einen `override` Member überprüft. Der überschreibende Member der am meisten abgeleitete Klasse wird aufgerufen, was der ursprüngliche Member sein kann, wenn keine erbende Klasse den Member überschrieben hat. Per Default sind Methoden `non-virtual` und lassen sich nicht überschreiben.

```{.csharp}
class TestClass
{
    public class Shape
    {
        public const double PI = Math.PI;
        protected double _x, _y;
        public Shape()
        {
        }
        public Shape(double x, double y)
        {
            _x = x;
            _y = y;
        }
        public virtual double Area()
        {
            return _x * _y;
        }
    }
    public class Circle : Shape
    {
        public Circle(double r) : base(r, 0)
        {
        }
        public override double Area()
        {
            return PI * _x * _x;
        }
    }

    static void Main()
    {
        double r = 3.0, h = 5.0;
        Shape c = new Circle(r);
        // Display results.
        Console.WriteLine("Area of Circle   = {0:F2}", c.Area());
    }
}
```

### abstract

Der Modifier `abstract` gibt an, dass das Objekt, welches geändert wird, eine fehlende oder unvollständige Implementation aufweist. Der `abstract` Modifier kann mit Klassen, Methoden, Properties, Indexern und Events verwendet werden und gibt in einer Klassen-Deklaration an, dass die Klasse ausschliesslich dazu dient, als Basisklasse für andere Klassen zu dienen. Member, die als `abstract` klassifiziert sind, müssen von `non-abstract` Klassen implementiert werden, die von der `abstract` Klasse erben.

```{.csharp}
abstract class Shape
{
    public abstract int GetArea();
}

class Square : Shape
{
    private int _side;

    public Square(int n) => _side = n;

    // GetArea method is required to avoid a compile-time error.
    public override int GetArea() => _side * _side;

    static void Main()
    {
        var sq = new Square(12);
        Console.WriteLine($"Area of the square = {sq.GetArea()}");
    }
}
// Output: Area of the square = 144
```

`Abstract` Klassen haben folgende Eigenschaften:
    - eine `abstract` Klasse kann nicht instantiiert werden
    - eine `abstract` Klasse kann `abstract` Methoden und Accessors beinhalten
    - eine nicht abstrakte Klasse, die von einer abstrakten Klasse abgeleitet wurde, muss Implementierungen aller geerbten abstrakten Methoden und Accessoren enthalten

`Abstract` Methoden haben folgende Eigenschaften:
    - eine `abstract` Methode ist implizit eine `virtual` Methode
    - abstrakte Methodendeklarationen sind nur in abstrakten Klassen zulässig
    - es gibt keinen Methodenkörper, da eine abstrakte Methodendeklaration keine Implementierungen bietet; die Methodendeklaration enden ganz einfach mit einem Semikolon; auf die Signatur folgen keine geschweiften Klammern
    - es ist unzulässig, die Modifizierer `static` oder `virtual` in einer abstrakten Methodendeklaration zu verwenden.

### override

Der Modifier `override` ist erforderlich, um die `abstract` oder `virtual` Implementierung von einer geerbten Methode, Property, eines Indexers oder eines Events zu erweitern oder zu ändern. Eine `override` Methode muss die selbe Signatur wie die überschriebene Basis-Methode haben. Der Rückgabetyp einer `override` Methode kann sich unterscheiden vom Rückgabetyp der korrespondierenden Basis-Methode. 

Eine `non-virtual` oder `static` Methode kann nicht überschrieben werden. Die überschriebene Base-Methode muss `virtual`, `abstract` oder `override` sein. Eine `override` Deklaration kann nicht die Zugänglichkeit auf die `virtual` Methode ändern. Die `override` und die `virtual` Methode müssen die selben access level modifier haben. Die Modifier `new`, `static`, oder `virtual` können nicht verwendet werden, um eine `override` Methode zu ändern.

```{.csharp}
abstract class Shape
{
    public abstract int GetArea();
}

class Square : Shape
{
    private int _side;

    public Square(int n) => _side = n;

    // GetArea method is required to avoid a compile-time error.
    public override int GetArea() => _side * _side;

    static void Main()
    {
        var sq = new Square(12);
        Console.WriteLine($"Area of the square = {sq.GetArea()}");
    }
}
// Output: Area of the square = 144
```

## Interfaces

`interface` sind komplett abstrakte Klassen und können nur Methodenprototypen, Delegates und leere Properties beinhalten, daher **keine** Implementationen. Sie bilden das Grundfundament für Basis- und Erweiterungsklassen.

```csharp
interface IAnimal {
  void animalSound(); // interface method 
  void run(); // interface method
}
```

Wenn Interfaces geerbt werden, muss der Inhalt des Interfaces implementiert werden, ansonsten ist das Programm nicht kompilierbar.

::: callout-caution
Es können keine Objekte von Interfaces erstellt werden!
:::

::: callout-note
Interfaces werden meist mit dem `I`-Präfix gekennzeichnet.

```csharp
interface IAnimal
```
:::

Interfaces können von einander erben und es kann einfach die neuen Inhalte eingefügt werden. Die explizite Implementierung findet in den Klassen statt.

```csharp
interface IAnimal {
  void animalSound();
}

interface IDog : IAnimal {
  void useSnout();
}
```

## Polymorphismus

```csharp
Animal animal = new animal();
Animal dog = new Dog();
```



## Klassendiagramme
