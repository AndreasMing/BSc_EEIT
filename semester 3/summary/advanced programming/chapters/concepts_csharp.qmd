## Collections

### Indexer

Indexer ermöglichen die Indexierung von Klassen oder Structs. Der Indexer wird mit dem `this` Keyword definiert. Indexer müssen nicht durch einen Integer-Wert indexiert werden und können überladen werden. Mehrere Parameter können verwendet werden, um beispielsweise auf ein zweidimensionales Array zuzugreifen.

```csharp
class Collection<T> {
  private T[] arr = new T[100];
  public T this[int i] {
    get => arr[i];
    set => arr[i] = value;
  }
}

class Program {
  static void Main() {
    var strCollection = new Collection<string>();
    strCollection[0] = "Hello, World!";
    Console.WriteLine(strCollection[0]);
  }
}
// output: Hello, World!
```

### Generics

Mit dem generischen Typenparameter `T` deklariert werden, bei welcher erst zur Deklaration der Datentyp instanziiert wird. Wenn eine Klasse mit einem kontreten Typen instanziiert wird, wird `T` mit dem Typen ersetzt.

```csharp
public class GenericList<T> {
  public void Add(T input) { }
}

class TestGenericList {
  private class ExampleClass { }
  static void Main() {
    // Declare a list of type int.
    GenericList<int> list1 = new GenericList<int>();
    list1.Add(1);

    // Declare a list of type ExampleClass.
    GenericList<ExampleClass> list2 = new GenericList<ExampleClass>();
    list2.Add(new ExampleClass());
  }
}
```

## Scope & Zugriff

## Overloading

::: callout-important
Overloading-Signaturen müssen sich in den **Datentypen** unterscheiden. Unterschiedliche Variabel-Namen führen zu einem *Compiler-Error*.
:::

### Konstruktor Overloading

Je nach Signatur können andere Konstruktoren aufgerufen werden. Dies nennt man auch *Overloading*. In folgendem Beispiel kann ein `Point` Objekt erstellt werden entweder mit oder ohne Angabe der Position.

```csharp
class Point {
  private int pos_x;
  private int pos_y;

  public Point(int x, int y) {
    this.pos_x = x;
    this.pos_y = y;
  }

  public Point() { }
}
```

#### Konstruktor Aufruf-Reihenfolge

Mit `this` nach dem Konstruktor (unterteilt mit `:`) kann der Aufruf auf einen anderen Konstruktor weitergereicht werden.

```csharp
using System;

class Point {
  private int x;
  private int y;

  public Point(int x, int y) {
    this.x = x;
    this.y = y;
    Console.WriteLine($"Point {this.x},{this.y}");
  }

  public Point(int x) : this(x, 0) {
    Console.WriteLine("x-only");
  }

  // Two identical signatures -> ERROR
  public Point(int y) : this(y, 0) {
    Console.WriteLine("y-only");
  }

  public Point() : this(0,0) {}
  Console.WriteLine("no value");
}
```

Wird nun `Point(4)` aufgerufen, werden die Parameter auf die unterste Ebene durchgereicht und die Konstruktoren werden in umgekehrter Aufrufreihenfolge abgearbeitet. So erhält man folgendes auf der Konsole

```output
Point 4,0
x-only
```

### Methoden Overloading

Je nach Signatur können andere Methoden aufgerufen werden. Dies nennt man auch *Overloading*. In folgendem können Flächen mit unterschiedlichen Angaben gerechnet werden.

```csharp
public int Area(int width, int height) {
  return width * height;
}

public int Area(int squareSide) {
  return squareSide^2;
}

public int Area(Point a, Point b) {
  return (a.x - b.x) * (a.y - b.y);
}
```

## Default Parameter

Für Default-Werte können Konstruktoren implizit Überladen werden.

```csharp
public void Draw(bool inColor = true) { ... }

// initialize drawing object
Draw inColor = new Draw();    // inColor = true
Draw bw = new Draw(false);    // inColor = false
```

## Garbage-Collector

## Signatur

## Exceptions

*Exceptions* sind in den meisten grundlegenden Funktionen implementiert und werden ausgelöst, wenn die Vorgaben nicht eingehalten werden. Ein Beispiel wäre ein Datenpacket via TCP zu verschicken, ohne zuerst mit dem TCP-Server zu verbinden.

### Exceptions abfangen mit `try` & `catch`

Zum Exceptions abfangen:

```csharp
try {
  // do stuff, that might raise an exception
}
catch (ArithmeticException e) { // explicit
  // catch Arithmetic Exception i.e. x/0
}
catch (Exception e) {
  // catch any other Exception
}
```

Die `catch`-"Parametern" müssen nicht unbedingt existieren, erlaubt aber den Fehler besser zu identifizeren.

### Erweiterung `finally`

Der `finally`-Codeblock wird verwendet, um etwas zu machen, bevor aus der Funktion gegangen wird. Ein Beispiel wäre eine Kommunikation zu beenden.

```csharp
try {
  // do stuff
  return thing;
}
catch (Exception e) {
  // catch raised exception
  return other_thing;
}
finally {
  // do stuff here before returning
}
```

### Exception werfen mit `throw`

```csharp
throw new ArithmeticException("string")
```

## Multithreading `System.Threading`


```csharp
static void Main(string[] args) {
  Thread t = new Thread(Run);
  t.Start();
  Console.ReadKey();
}

static void Run() {
  Console.WriteLine("Thread is running...");
}
```

### Sync

### Deadlock

### Parametrisierter Thread

Falls ein Parameter übergeben werden muss, kann die delegierte `ParameterizedThreadStart`-Signatur verwendet werden. Der Thread wird normal aufgesetzt und bei `.Start()`

```csharp
static void Main(string[] args)
{
  //...
  TcpClient client = listener.AcceptTcpClient();
  Thread t = new Thread(HandleRequest);
  t.Start(client);
  // ...
}

// must be of ParameterizedThreadStart signature
private void HandleRequest(object _object)
{
  TcpClient client = (TcpClient)_object;
  // ...
}
```

## Boxing & Unboxing

*Boxing* und *Unboxing* ermöglicht das Konvertieren von Wertetypen (`int`, `Bool`, `struct`) in Referenztypen (z.B. `object`) und zurück. Dies kann hilfreich sein wenn z.B. Wertetypen in einer Sammlung gespeichert werden soll, welche nur Referenztypen akzeptiert.

Im folgenden Beispiel wird der Integerwert $123$ *geboxed* (impliziter cast) und das neue Objekt zeigt nun auf den geboxted Integer. Zum *unboxen* muss **explizit** gecastet werden!

```csharp
int i = 123;
object o = i; // box the int

// o -> `123`

int j = (int)o; // unbox the object
```

## Streams

Streams (*Datenströme*) sind ein grundlegendes Konzept für Daten Ein-/Ausgabe. Streams abstrahieren ein dahinterliegendes I/O-Gerät (z.B. Datei, Tastatur, Konsole, Netzwerk, ...) und lassen so C#-Programme Daten darauf lesen oder schreiben. Es wird der Namespace `System.IO`{.csharp} genutzt und alle Streams implementieren die abstrakte `System.IO.Stream`{.csharp} Klasse.

* `FileStream` zum schreiben von Files
* `TextReader` und `TextWriter` für I/O mit Unicode-Zeichen
* `BinaryReader` und `BinaryWriter` für I/O mit Binärdaten
* `MemoryStream` liest und schreibt in den Speicher
* `BufferdStream` erhöht die Performance
* `CryptoStream` zur verschlüsselung von I/O

Beispiel-Code zum Komprimieren, Schreiben und Lesen einer Datei:

```csharp
// Text to file
// BinaryWriter -> GZipStream -> 
// CryptoStream -> Filestream -> Datei 
// Initialize streams in opposite direction 
// (Always from file to top-level-function)
FileStream fs = new FileStream("./Chaining.txt", 
                               FileMode.Create);
GZipStream gs = new GZipStream(fs, 
                      CompressionMode.Compress);
BinaryWriter bw = new BinaryWriter(gs);

// Write
bw.Write("Hello File");
bw.Flush();
bw.Close();

// file to Text
// BinaryReader <- GZipStream <- 
// CryptoStream <- Filestream <- Datei
// Initialize in streams direction 
//(Always from file to top-level-function)
FileStream fsB = new FileStream("./Chaining.txt", 
                                FileMode.Open);
GZipStream gsB = new GZipStream(fsB, 
                      CompressionMode.Decompress);
BinaryReader brB = new BinaryReader(gsB);

// Read
string msg = brB.ReadString();
brB.Close();

// ...
```

::: callout-important
* `.Write( ... )` um etwas an den Buffer des Streams zu übergeben
* `.Flush()` um den Buffer zu leeren *(Übertragen)*
* `.Read()` um etwas aus dem Stream zu lesen
* `.Close()` um den Stream zu schliessen **!Immer!**
:::

## Delegates

### Multicast

## Events
