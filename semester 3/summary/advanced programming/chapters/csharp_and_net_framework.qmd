## Vergleich `C` & `C#`

|                 |                      C *(POP)*                     |                   C# *(OOP)*                  |
|:---------------:|:--------------------------------------------------:|:---------------------------------------------:|
|                 | **P**rozedurale **O**rientierte **P**rogrammierung | **O**bjekt **O**rientierte **P**rogrammierung |
|   Compilation   |                     Interpreter                    |              Just-in-time *(CLR)*             |
|    Execution    |                   Cross-Platform                   |                `.Net` Framework               |
| Memory handling |              `free()` after `malloc()`             |               Garbage collector               |
|    Anwendung    |             Embedded, Real-Time-Systeme            | Embedded OS, Windows, Linux, GUIs             |
|  Execution Flow |                      Top-Down                      |                   Bottom-Up                   |
|  Aufteilung in  |                     Funktionen                     |                    Methoden                   |
|   Arbeitet mit  |                     Algorithmen                    |                     Daten                     |
| Datenpersistenz |      Einfache Zugriffsregeln und Sichtbarkeit      | Data Hiding (`privat`, `public`, `protected`) |
|  Lib-Einbindung |              *.h* File mit `#include`              |            *namespaces* mit `using`           |

[]: # (Do more as you'd like. See table "VergleichC.tgn" to use on "https://www.tablesgenerator.com/markdown_tables")

`\begin{multicols}{2}`{=latex}

## Struktur `C#`-Programm

### Namespace

```csharp
namespace { ... }
```

`namespace` dient zur Kapselung von Methoden, Klassen, etc., damit zum Beispiel mehrere Klassen/Methoden gleich benannt werden können.

```csharp
namespace SampleNamespace {
  class SampleClass {...}
  struct SampleStruct {...}
  enum SampleEnum {a, b}
  namespace Nested {
    class SampleClass {...}
  }
}

namespace NameOfSpace {
  class SampleClass{...}
  ...
}
```

Zum Aufrufen von Klassen/Methoden anderer `namespace`'s kann dieser über `using` eingebunden werden oder der Aufruf geschieht über `namespace.SampleClass`.

### Klassen

Klassen beschreiben den Bauplan von Objekten. Wenn man das nicht versteht, nützt dir auch der Rest der Zusammenfassung nichts ;)

Eine Klasse ist eine Sammlung von **Daten** und **Methoden**.

::: callout-important
* Pro Datei eine Klasse
* Klassenname = Dateiname
* Klassenname beginnt mit Grossbuchstabe: `MyClass`
:::

Klassen können mit dem Schlüsselwort `static`{.csharp} statisch angelegt werden. Von statischen Klassen können keine Objekte erstellt werden, die Mehtoden sind immer über den Klassennamen aufrufbar. Ein Beispiel hierfür ist die `System`{.csharp} Klasse.

```{.csharp}
System.Console.WriteLine("Hallo Welt");
```


### Konstruktor

Konstruktoren werden beim Erstellen von neuen Objekten aufgerufen. Ihnen können Parameter oder andere Objekte übergeben werden.

```{.csharp}
public class Point{
  int size;

  public Point(int size) {
    this.size = size;
  }
}

public Program{
  satic void Main(){

    // initialize new Point object
    Point smallPoint = new Point(2);
  }
}
```

::: callout-tip
 Der Default-Konstruktor nimmt keine Parameter entgegen. Wird ein Konstruktor angegeben, so ist der Default-Konstruktor nichtmehr aufrufbar.
:::

### Destruktor

Destruktoren werden verwendet um die Resourcen von Objekten freizugeben. Es ist bereits ein Standard-Destruktor implementiert, welcher nur in seltenen Fällen überschrieben wird. Der Destruktor wird automatisch vom Garbage-Collector aufgerufen.

```{.csharp}
public class MyClass
{
    // Other members of the class...
    ~MyClass()
    {
        // Release resources held by the object here.
    }
}
```

### Methode

Methoden sind das C#-pendant der Funktionen in C. Der Zugriff auf Methoden kann mit Zugriff-Modifizierern *(siehe @sec-modifier)* eingeschränkt werden.

Methoden werden über Objekte aufgerufen

```{.csharp}
MyClass NewObject = new MyClass("some string");
NewObject.DoSomething();

public class MyClass{
  public void DoSomething(){
    // do something
  }
}
```

Um Methoden ohne Objekte aufzurufen ist das Schlüsselwort `static` nötig.

```{.csharp}
NewObject.DoSomething();

public class MyClass{
  public static void DoSomething(){
    // do something
  }
}
```

Die `Main(string[] args) {}`{.csharp} Methode beschreibt den Einstiegspunkt eines Programms. In `args`{.csharp} sind Programm-Parameter gespeichert welche z.B. bei einer Konsolenaplikation angefügt werden *(hier `-debug`)

```{.bash}
dotnet MyProgram.dll -debug
```

### Membervariable

Membervariabeln sind **Daten** oder **Attribute** eines Objektes. So ist z.B. `color` eine Membervariable in deiner Klasse `car`. Membervariablen können mit Zugriff-Modifizierern *(siehe @sec-modifier)* eingeschränkt werden.

Deklaration:

```{.csharp}
public class Point{
  private int xPos = 0;
  private int yPos = 0;
}
```
Für Membervariablen wird auf dem **Heap** Speicher reserviert. Membervariablen sollten explizit initialisiert werden, die Standardwerte der automatischen Initialisierung sind:
* Numerische Typen **`0`**
* enum **`0`**
* boolean **`false`**
* char **`'\0'`**
* Referenzen **`null`**

::: callout-important
* Pro Enum eine Datei
* Member beginnen mit Kleinbuchstaben: `fristName`
* Enum's und Klassen beginnen mit Grossbuchstaben: `Person`, `Gender`
* Member sollten grundsätzlich `private` sein
* Enum's und Klassen sind grundsätzlich `public`
* Member explizit initialisieren: `int x = 0;`
:::

### Property

## .Net Bibliotheken

### `System`

#### `Sysem.Console`

## Keywords

### Operatoren & Abarbeitungsreihenfolge

### Zugriffs-Modifier {#sec-modifier}

![](images/AccessModifiers.png)

*Modifier* sind auf Klassen, Enum, Membervariablen, Properties und Methoden anwendbar.

### `using`

Die `using`-Direktive teilt dem Compiler mit welcher `namespace` während der Compilierung verwendet werden soll. Wenn `using` nicht verwendet wird, muss bei einem Methodenaufruf auch der entsprechende `namespace` genannt werden.

```csharp
// w/o `using`
System.Console.WriteLine("Hello World!");

// w/ `using`
using System;
...
Console.WriteLine("Hello World!");
```

### `static`

### `const`

### `readonly`

## Datentypen

Wie in C gibt es in C# Wertetypen und Referenztypen

![](images/Types.png)

### `class`


### `struct`

::: callout-important
## Unterschied `struct` & `class`

`struct`s sind *value* Typen und übergeben jeden Wert/Eigenschaften. `class`es sind *reference* Typen und werden als Referenz übergeben.

- `class` $\rightarrow$ call by reference (Übergabe als Reference)
- `struct` $\rightarrow$ call by value (Übergabe als Wert)

:::

### `string`

Strings werden mit dem folgender Deklaration 

::: callout-important

Strings können nicht verändert werden -> sind **read-only**

```csharp
string s = "Hallo Welt";

s[1] = 'A'; // ERROR
```

:::

#### Stringformatierung

Parameter/variablen können in Strings direkt eingefügt werden.

```{.csharp}
// C-Sytle
Console.WriteLine("{0} + {1} = {2}",a,b,res);

// C#-Style
Console.WriteLine(a + " + " + b + " = " + res);

// C# formatted string
Console.WriteLine($"{a} + {b} = {res}");
```

### Aufzählungstypen (`enum`)

Enumerationen sowie Klassen sollten der Übersichtlichkeit wegen in eigenen Dateien erstellt werden. Um Enums in logischen Operation oder als Flags zu nutzen kann dies mit dem Attribut `[Flags]`{.csharp} angegeben werden.

```{.csharp}
// File: ButtonState.cs
[Flags]
public enum Button{
  NONE = 0,
  LEFT = 1,
  RIGHT = 2,
  UP = 4,
  DOWN = 8
}
```

Verwendet werden Enums mit ihren Namen (`Button btn = Button.LEFT`{.csharp}). Zudem können diverse Rechenoperationen auf sie angewendet werden.

```{.csharp}
// Vergleich
  if(c == Colors.Yellow) ...                    
  if(c > Colors.Green && c < Colors.Yellow) ...
// +, -, ++, --
  c = c + 1;    c++;                                
// &, |, ~
  btn.UP & btn.DOWN  // = "12" -> UP, DOWN      
```



### Array
