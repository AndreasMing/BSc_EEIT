---
format:
  chribel-summary-quarto-pdf:
    include-in-header:
    - text: "\\usepackage[datesep=.]{datetime2}"
    - text: "\\DTMsetdatestyle{ddmmyyyy}"
    - text: "\\usepackage{blindtext}"
    toc: true
    classoption: twocolumn

# [DOCUMENT INFORMATION]
title: "Embedded Systems and Advanced Computing"
subtitle: "ENCE464"
author: "Andy Ming"

# [PAGE OPTIONS]
lang: en-GB
babel-lang: ukenglish

# [HEADER & FOOTER]
fancyhdr:
  header:
    right: "Embedded Systems & Advanced Computing"
    center: ""
    left: "University of Canterbury"
  footer:
    right: "ENCE464"
    center: "\\thepage\\ / \\pageref{LastPage}"
    left: "\\today"
  
source:
  github: "https://www.youtube.com/watch?v=VGhcSupkNs8"

accentcolor: "124E82" # must be given as hex, sadly :(

chribel-fontfamily:
  - name: AlegreyaSans      # used for section headings, title page
  - name: cmbright          # used for paragraph and math
  - name: inconsolata
    options: "scaled=0.95"  # for code blocks
---

# How to work code

Remember that software engineering is 50-70% maintenance. Because modern machines heavily rely on microcontrollers there is great demand.

![](images/paste-3.png){fig-align="center" width="30%"}

Software engineering has many different aspects (the dark blue ones are focused on here), find out more [here](https://www.computer.org/education/bodies-of-knowledge/software-engineering/topics).

![](images/paste-1.png){fig-align="center" width="25%"}

## Feature Branches

To implement different features, use a branch per feature, this guarantees that the main is always in working condition.

![](images/paste-2.png)

::: callout-important
## Branching Rules

-   Feature branches are **temporary** branches for new features, improvements, bug fixes or refactorings.
-   Don't push directly to **master/main**.
-   Each feature branch is owned by **one** developer.
-   Only do merge requests on **complete** changes i.e. [don’t break main]{.underline}.
-   Thoroughly test your change prior to **starting** AND prior to **completing** a merge request.
-   Use your commit messages to tell the **story** of your development process.
:::

To minimise integration issues:

-   A feature branch should only hold a small increment of change
-   If main is updated during feature development, merge the new main into your feature branch **locally**, **before** making a merge request

## Clean Code

::: callout-warning
## Smells of Bad Code

-   *Rigidity*: Changing a single behaviour requires changes in many places
-   *Fragility*: Changing a single behaviour causes malfunctions in unconnected parts
-   *Inseparability*: Code can't be reused elsewhere
-   *Unreadability*: Original intent can't be derived from code
:::

### Reveal Intent

``` cpp
// BAD
uint16_t adcAv;  // Average Altitude ADC counts
// GOOD
uint16_t averageAltitudeAdc;
```

### Don't Repeat Yourself (DRY)

Avoid duplicate code $\rightarrow$ Put it into a function. Can you put it in a function? Then you should!

### Consistent Abstraction

**High-Level** ideas shouldn't get lost in **Low-Level** operations.

``` cpp
// Bad Example
deviceState.newGoal = readADC() * POT_SCALE_COEFF;   // low-level
deviceState.newGoal = (deviceState.newGoal / STEP_GOAL_ROUNDING)*STEP_GOAL_ROUNDING;  // high-level
```

### Encapsulation

-   *Hide* as much as possible
-   *Public* Interface: Header File, only declare what other modules need to know
-   *Private* / Inner Workings: Source File
-   *Avoid* global variables $\rightarrow$ Use *getter* & *setter*

### Comments

More comments $\neq$ better quality. Use comments only to:

1.  Reveal intent after you tried everything else
2.  Document public APIs - sometimes

### Code Reviews

Use *merge requests*, label feeback as *bug, code, quality, preference*.

![](images/paste-14.png){fig-align="center" width="40%"}

## SOLID

How to make designs **flexible**, as requirements change all the time (Agile).

![](images/paste-31.png)

*SOLID* is all about **managing dependencies**.

![](images/paste-32.png)

### Single Responsibility Principle (SRP)

*"A module should only have a single responibility. It should only have one reason to change"*

Instead of `ADC_read` which handles the ADC reading, averaging and the setting of the new goal, we breack it up into a module `ADC_HAL` which handles the ADC reading and averaging and the module `new_goal_reader` which just handles the setting of the new goal.

-   A module does **one thing** and does it **well**
-   Use good names, reveal intent
-   Don't access numerous data structures and globals

### Open-Closed Principle (OCP)

*"Software entities (modules, functions) should be **open to extension, but closed for modification**"*

The `new_goal_reader` doesn't have to be modified in case of a hardware change. But it's functionality can be extended through swapping out the HAL implementation.

-   Changes through adding code instead of modifying
-   aka USB standard: Plug-n-Play, no hardware change needed
-   OOP use "interface" or "abstract class"
-   C use "header files" or "function pointers"

### Liskov Substitution Principle (LSP)

*"Subtypes should be substitutable with their base types"*

`TIVA ADC HAL` is perfectly substitutable with its base type of the `ADC HAL` interface.

### Interface Segregation Principle (ISP)

*"Clients should not be forced to depend on functions that they do not use"*

The interface `ADC HAL` is defined on the needs of `new_goal_reader` (the client). Don't show unneeded functions.

-   Write "small" interfaces
-   Allows to limit dependencies

### Dependecy inversion Principle (DIP)

*"High-level modules should not depend upon low-level modules. Both should depend on abstraction"*

The interface `ADC HAL` is the abstraction and both, `new_goal_reader` and `TIVA ADC HAL`, are implementing this. `new_goal_reader` doesn't know (and care) which implementation is called.

In OOP this is called **Polymorphism**.

## SOLID Models for C

::: callout-tip
## How much design is enough?

-   Use simplest flexible design for today's requirements
-   Changing requirements $\rightarrow$ Change **Design**
-   Tests ensure functionality is retained
:::

### Single Instance Model

![](images/paste-33.png){fig-align="center" width="7cm"}

### Multiple Instance Model

-   Create multiple instances
-   Use abstract data type (ADT) $\rightarrow$ object definitions and details are **encapsulated**
-   Public functions to operate on the abstract data type `f(O,x)`
-   **Multiple** instance, **Static** binding

``` cpp
// In header file
typedef struc circBuf circBuf_t;

// In source file
struct circBuf {
    uint32_t size;
    uint32_t windex;
    uint32_t rindex;
    int32_t *data;
}
```

### Dynamic Interface

![](images/paste-34.png){fig-align="center" width="7cm"}

-   Configuration determined in runtime
-   Interface is a *public struct of function pointers*
-   **Single** instance, **Dynamic** binding

### Pre-Type Dynamic Interface

-   Support any number & combination of drivers
-   Each type has its own constructor
-   Objects cast to abstract interface
-   Have a array of abstract instances
-   **Multiple** instance, **Dynamic** binding

## Design Patterns

23 patterns introduced by the **G**ang **o**f **F**our (GoF), for **Dependency Management**. There are 3 types:

-   **Creational**: Create instances of objects
-   **Structural**: Set communication pathways
-   **Behavioural**: Distribute responsibilities

![](images/paste-35.png){fig-align="center" width="8cm"}

::: callout-tip
## Recommendations

-   Don't overcomplicate, design for todays requirements
-   Use pattern if beneficial, maybe simple code is sufficient
-   Customise patterns to application
:::

### Adapter Pattern

-   What: Wrap adapter around another module to give it a more desirable interface
-   Hiding ugly interfaces of a 3rd-party service
-   Hiding data conversions
-   Make incompatible modules compatible
-   Fulfills SRP, ISP, LSP

![](images/paste-36.png){fig-align="center" width="7cm" height="2.4cm"}

### State Pattern

-   What: Module will behave differently depending on internal states
-   Allows implementation of FSM without several lengthy conditional statements
-   State is saved in the private `currentState` variable
-   There is a module implementation per state
-   The client initialises the context with a state
-   Fulfills SRP, OCP

![](images/paste-37.png){fig-align="center" width="9cm" height="2.4cm"}

### Command Pattern

-   What: Turns request into a stand-alone object
-   Invoker calls receiver through command object
-   Client attaches invoker with its commands
-   Multiple things can execute one command
-   Command is placed in queue until receiver is ready
-   Triggers can invoke series of commands
-   Fulfills SRP, OCP

![](images/paste-38.png){fig-align="center" width="8.5cm"}

## Legacy / Vererbt / Veralteter Code

If handed bad quality (no tests, no encapsulation, no good practices, ...) and you have to add features you can either (1) *add to the mess by hacking in new features* or (2) *rewrite code from scratch*.

The issues are (1) will *reduce productivity* and it's *easy to introduce bugs* but (2) is very *time consuming*, it's *difficult to maintain two versions* (there might still be old versions in the field which have to be maintained) and there will be a *new set of bugs* to deal with.

So we try to refactor until it's easy to make changes. To preserve functionality we iterate *in small increments* with **Trageted Tests** *(allows changes and new features to happen at the same time)*:

1.  **Write tests** of the code you need to change
2.  **Test drive** changes to legacy code
3.  **Test drive** new code
4.  **Refactor** tested area

Also add **Characterisation Tests** where understanding is required. *Tests are a living documentation*.

To make sure *key functionality* isn't altered, add **Strategic Tests**. (e.g. control algorithm, safety-critical error detection, ...)

::: callout-note
## Putting Code Under Test

1.  Identify are of code to test (targeted, characterisation, strategic)
2.  Find test points (function calls, global variables $\rightarrow$ encapsulate ASAP, serial)
3.  Break dependencies (Solitary tests)

![](images/paste-21.png){fig-align="center" width="8cm" height="4.6cm"}
:::

# Embedded Software Design

## Architecture

Architecture are "important" structures, every structure is important for a specific part of the software. There are several different structures in embedded software systems.

::: callout-note
## Architecture Goals

-   *Understandability* - In Development & Maintenance
-   *Modifiability* - Through "best practices"
-   *Performance* - Reduce Overheads

Other possible requirements: Portability, Testability, Maintainability, Scalability, Robustness, Availability, Safety, Security
:::

**Static Structures:** Conceptual abstraction a developer works with

![](images/paste-4.png){fig-align="center" width="40%"}

**Dynamic Structures:** Relationships that exist in executing software

![](images/paste-9.png){fig-align="center" width="40%"}

**Allocation Structures:** Assignment of software elements to external things

![](images/paste-10.png){fig-align="center" width="40%"}

Patterns are always a combination of tactics, depending on what you're trying to achieve.

![](images/paste-11.png)

::: callout-important
## Trade-Offs

Quality attributes can conflict with each other. For example:

![](images/paste-12.png){fig-align="center" width="60%"}
:::

::: callout-note
## Keep Record of Decisions

To keep record of decisions and to not loose the overview use tools like:

-   *Architecture Haikus*: A onepager overview of your document [see here or in the appendix folder](https://ieeexplore.ieee.org/document/7093016).

-   *Architecture Decision Records*: A incremental document to record decisions on the go [either in a tool or a markdown file](https://adr.github.io/).
:::

### Layered

Each layer is is providing services to the above layer through well-defined interfaces. Each layer can only interact with the layer directly above or below.

Supports portability and modifiability by allowing internal changes to be made inside a layer without impacting other layers, and isolating changes in layer-to-layer interfaces from more distant layers.

![](images/paste-5.png){fig-align="center" width="30%"}

### Ports-and-Adapters (or *Hexagonal*)

Introduces a single core logic which communicates through abstraction interfaces (**Ports**) to different modules. The **Adapters** map the external interactions to the standard interface of the port.

Supports portability and testability by making the inputs to the ports independent of any specific source, and supports modifiability by creating a loose coupling between components.

![](images/paste-6.png){fig-align="center" width="40%"}

### Pipes-and-Filters

Supports modifiability through loose coupling between components, and performance by introducing opportunities for parallel execution.

![](images/paste-7.png){fig-align="center" width="40%"}

### Microkernel

RTOS is a implementation of a Microkernel Architecture. The **Microkernel** includes a set of common core services. Specific services (**Tasks**) can be plugged into the kernel.

Supports modifiability and portability.

![](images/paste-8.png){fig-align="center" width="25%"}

#### Tasks for Priority and Modularity

\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\begin{itemize}
    \item[+] Control Priority
    \item[+] Control Response Time
    \item[+] Modularity
    \item[-] Concurrency Issues
    \item[-] Overhead (Scheduler)
    \item[-] Starvation (Task gets no CPU time)
\end{itemize}

![](images/paste-27.png){fig-align="center" width="6cm"}

Use **just enough** tasks.

## RTOS

To improve **Performance** we introduce **Concurrency** (Run tasks in parallel).

![](images/paste-15.png){fig-align="center" width="25%"}

Preemptive approach: *Separation* of concerns, *Scalability*, State is *Managed.*

Do the ***right thing*** at the ***right time*** $W$

![](images/paste-17.png){fig-align="center" width="40%"}

::: callout-note
## RTOS vs. Desktop OS

-   Desktop OSs don't try to achieve *hard* real-time performance
-   In a Desktop OS, programs can be loaded in runtime
-   RTOS is compiled as part of the application, to add a new "program" the application has to be recompiled
:::

### Tasks

``` cpp
xTaskCreate(
    BlinkTask,    // Function that defines task 
    "Blink Task", // Task name (used in debugging) 
    STACK_SIZE,   // No. of 4-byte words for stack
    NULL,         // Optional pointer to task argument 
    PRIORITY,     // Higher number = higher priority 
    NULL);        // Optional pointer to task handle
```

Taskswitches happen at *scheduling points* which occur when a **task is blocked**, **interrupt causes a task**, **priority change**, **higher priority task gets ready** or **system tick interrupt**.

![](images/task_states.png){fig-align="center" width="40%"}

#### Stack Size

::: callout-important
## Stack Size Value

The stack size value passed in `xTaskCreate` is measured in **4-Byte** words.

Set high margins, something like **300%**
:::

-   Minimal: `configMINIMAL_STACK_SIZE`

-   Maximal: Device *RAM*

-   Actually: Analyse

    -   Dynamic: Set something and see if it works / use `uxTaskGetStackHighWaterMark` to measure

    -   Static: Use tools (e.g. GCC `-fstack-usage`) to attempt reading on how much stack is needed per function

#### Priority

Task priority has a strong influence on when a task is run and thus on the overall behaviours of the application.

**Assign priority based on importance**

1.  Separate tasks into "critical" (hard deadline) and "non-critical" (soft deadline)
2.  Assign low priority to non-critical tasks
3.  To be sure about critical tasks meeting their deadlines, apply scheduling theory

**Assign non-critical tasks to low priorities**

1.  Either apply the same priority for all non-critical tasks
2.  Or prioritise by *importance*, which depends on
    a.  Shortness of Deadline
    b.  Frequency of Execution
    c.  Need for Precessor time

**Assign critical tasks *deadline monotonic* priorities**

Apply priority based on the size of it's deadline.

1.  Highest $\leftarrow$ shortest deadline
2.  Lowest $\leftarrow$ longest deadline

::: callout-tip
## Deadline / Rate Monotonic Priorities

Deadlines $D_i$ and Period $T_i$ for each task $i$

**Deadline Monotonic**: $D_i \leq T_i$

**Rate Monotonic**: $D_i = T_i$

Futhermore, following assumptions are made:

-   Fixed-priority preemptive scheduling
-   Hard-Deadline tasks are either:
    -   *Periodic* (fixed interval)

    -   *Sporadic* (known minimum time between triggering events)
:::

#### Check Schedulability of Critical Tasks

To check if deadlines can be met (schedulable) we calculate the **response time upper bound** $R^{ub}_i$ for each task $i$. This has to be less than the task deadline $D_i$

$$
R^{ub}_i \leq D_i
$$

The tasks are ordered after priority from $i=1$ (highest priotity) and so on. Then Calculate the upper bound for every task through

$$
R_i^{ub}=\frac{C_i+\sum_{j=1}^{i-1}C_j(1-U_j)}{1-\sum_{j=1}^{i-1}U_j}
$$

$$
\begin{array}{l}
C_i \text{ worst case execution time (WCET)} \\
U_i \text{ utilisation } U_i = \frac{C_i}{T_i} \\
T_i \text{ task period}
\end{array}
$$

Thus $R_1^{ub}=C_1$ ans each lower priority task has a response time that depends on the utilisation of the tasks above it.

::: callout-caution
## Response Time Upper Bound

-   If task $R^{ub}_i \leq D_i$ checks, task is practically schedulable
-   If task fails test, there is still chance for it to work, as there've been many assumptions
-   Response times tests don't account for task interactions and os overhead
-   Tests depend on some kind of worst case execution time per task
:::

![](images/paste-20.png){fig-align="center" width="40%"}

#### Estimating WCET

To estimate **W**orst **C**ase **E**xecution **T**ime, there are two basic approaches

**Static Analysis** (Analysis of the source code)

-   Relies on good processor model
-   Good for simple code & MCU
-   Difficult for complex code & MCU

**Dynamic analysis** (Measurement at runtime)

-   Common in industry
-   Must be able to exercise worst-case path
-   Simple: Toggle GPIO

### Concurrency / Gleichzeitigkeit

Tasks "logically happen" at the same time, either physically (multi-core) or through context switches (single-core). This should improve **Responsiveness**.

![Tasks of different priority in a preemptive RTOS](images/paste-18.png){fig-align="center" width="50%"}

-   **Cooperative** multi-tasking: Tasks determine whether they give control back or not
-   **Preemptive** multi-tasking: A scheduler takes control of what task gets how much time and also pulls tasks from executing

::: callout-note
## Important Properties

**Safety**: Nothing bad ever happens

**Liveness**: Something useful eventually happens

**Responsiveness**: Eventually is a reasonable amount of time
:::

#### Cooperative Round-Robin

\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\begin{itemize}
    \item[+] Simple
    \item[•] No priorities
    \item[•] Worst case response = sum of all task times
    \item[•] Scheduling can be deterministic, but task periods must be harmonic
    \item[-] Must manually manage state of long-running tasks
    \item[-] Any change may alter response times
\end{itemize}

#### Preemptive: Fore-/Background

![](images/paste-19.png){fig-align="center" width="40%"}

\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\begin{itemize}
    \item[+] Prioritise tasks
    \item[+] Separation of tasks and scheduling eases change
    \item[•] Worst case response = interrupt time + longest task time
    \item[•] Time-triggered scheduling deterministic, task harmonic
    \item[-] Complex task handling / 3rd-party microkernel
    \item[-] Race conditions for interrupts
    \item[-] Manual managing of long-running tasks
\end{itemize}

#### Preemptive: RTOS Impelementation

Each task is written as if it is a *single main loop*.

``` cpp
// Main Setup
#include <FreeRTOS.h>
#include <task.h>
void main() {
    xTaskCreate(BlinkTask, "BlinkA", STACK_SIZE, NULL, BLINK_PRIO, NULL);
    xTaskCreate(BlinkTask, "BlinkB", STACK_SIZE, NULL, BLINK_PRIO, NULL);
    vTaskStartScheduler();
}

// The Task
void BlinkTask(void* pvParameters) {
    while(true) {
        ledInvert();
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}
```

\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\begin{itemize}
    \item[+] Prioritise tasks and responses
    \item[+] Separation of tasks and scheduling eases change
    \item[+] Long-running tasks are scheduler managed
    \item[+] Scheduling is flexible
    \item[+] Usefull features (timing-services, protocol stacks, multi-processors,...)
    \item[•] Worst-case response = interrupt time + scheduler context switch
    \item[-] Depending on 3rd-party microkernel
    \item[-] Must manage raceconditions on recourses
    \item[-] OS overhead costs recources
\end{itemize}

::: callout-warning
## Concurrency Issues

**Race Condition**: Outcome depends on timing $\rightarrow$ Occur when task modify **shared data**

![](images/paste-22.png){fig-align="center" width="7cm" height="4.5cm"}

**Containment**: Keep data within a task

**Immutability**: Use unchanging data

**Atomic Data**: Only share data which can be changed atomically

**Critical Section**: Section of code must execute *atomically* (in one run)

**Synchronisation**: Concurrency Control
:::

#### Mutex (Mutual Exclusion)

Only one task can take / lock the mutex at a time. Other task trying to acquire the mutex are blocked until the mutex is released. A mutex can only be ***released** by the task that **acquired** it*.

If two or more tasks **share a recource**, use a mutex for protection.

``` cpp
#include <semphr.h>
SemaphoreHandle_t mutex = xSemaphoreCreateMutex();
...
// in a task
for (int32_t i = 0; i < 1000000; i++) {
    xSemaphoreTake(mutex, portMAX_DELAY);
    counter = counter + 1;
    xSemaphoreGive(mutex);
}
```

::: callout-note
## Encapsulate Synchronization

-   Avoid scattering mutexes around the code
-   Prevent client tasks of accessing mutexes directly
-   Ensure only a single mutex is hold at a time

``` cpp
// counter_manipultor.c
static SemaphoreHandle_t mutex;
static int32_t counter = 0;

void counterAdd(int32_t value) {
    xSemaphoreTake(mutex, portMAX_DELAY);
    counter = counter + value;
    xSemaphoreGive(mutex);
}
int32_t counterGetValue() {
    xSemaphoreTake(mutex, portMAX_DELAY);
    int32_t local = counter;
    xSemaphoreGive(mutex);
    return local;
}

// counter_task.c
void CounterTask(void* pvParameters) {
    for (int32_t i = 0; i < 100; i++) {
        counterAdd(1);
    }
    int32_t final = counterGetValue();
    printf“(%”d, final);
    vTaskSuspend(NULL);
}
```
:::

#### Semaphore

A semaphore can be ***given** by any task*. To receive and wait for a signal use `xSemaphoreTake(...)`.

If two or more tasks need to **coordinate actions**, use a semaphore to send signals.

``` cpp
SemaphoreHandle_t signal = xSemaphoreCreateBinary();
void TaskA(void* pvParameters) {
    for (;;) {
        printf("Ready!");
        xSemaphoreGive(signal);
        vTaskSuspend(NULL);
    }
}
void TaskB(void* pvParameters) {
    for (;;) {
        xSemaphoreTake(signal, portMAX_DELAY);
        printf("Go!");
        vTaskSuspend(NULL);
    }
}
```

#### Task Notification

Task notifications are FreeRTOS specific and offer a *light weight* alternative to a semaphore.

#### Queues

Used to send data from one task to the other. Data is written to a queue **as copy**.

``` cpp
// create queue
#include <queue.h>
QueueHandle_t msgQueue = xQueueCreate(QUEUE_SIZE, sizeof(msg_t));

// send a message
xQueueSend(msgQueue, &toSend, 0);

// receive a message
xQueueReceive(msgQueue, &received, portMAX_DELAY);
```

`xQueueReceive(..., portMAX_DELAY)` is blocking until something is put into the queue. The time can be adjusted by the last argument, usually `portMAX_DELAY`, veeeeery long.

#### Deadlock

.

![](images/paste-26.png)

We can also design tasks to only block in one place and thus deadlocks are less likely

``` cpp
void Task(void* pvParameters) {
    for (;;) {
        xQueueReceive(...); // single block
        switch (received.msgType) {
            case MSG_A: // Handle A events 
            case MSG_B: // Handle B events 
            case TIMER_1: // Handle timer 
            case default: // Assert?
        }
    }
}
```

Or use a structure which prevents deadlocks generally

![](images/paste-28.png){fig-align="center" width="8cm"}

Use a **Pipeline** to minimise circular dependencies and a **Client-Server** structure to restrict the directionality of connections.

#### Priority Inversion

.

![](images/paste-25.png)

## Resources

::: callout-note
## Ausgangslage TIVA

32KB RAM, 256KB ROM, Low-Power

FreeRTOS needs: 5-10KB ROM, RAM: 236bytes (scheduler), 76bytes + storage size (queue), 60 bytes + stack size (task)
:::

::: callout-warning
## Premature optimization is the root of all evil.

Don't optimize before you know your constraints.
:::

![](images/paste-41.png)

### Choose

#### Get the memory map

``` cpp
set(CMAKE_EXE_LINKER_FLAGS) {
    ...
    -Xlinker
    -Map=${SMAKE_CURRENT_BINARY_DIR}/%
    ...
}

// output
... 
.text 0x00000470 0x280 accl_manager.c.obj
      0x00000470 acclInit
      0x00000488 acclProcess
...
```

The distance between two functions equals their size (mostly).

#### Use `objdump -d` to disassemble executable

![](images/paste-44.png){fig-align="center" width="7cm" height="4.5cm"}

#### Profiling

-   Use GPIO and oscilloscope to profile how long certain parts of a function run
-   Use a DIY sampling profiler

``` cpp
(gdb) continue Continuing.
^C Program received signal SIGINT, Interrupt. prvIdleTask (pvParameters=0x0 <vPortValidateInterruptPriority>)
    at FreeRTOS/Source/tasks.c:3487
3487                vApplicationIdleHook();
```

### Change

#### Flyweight pattern

Task refers to same immutable data over and over again

![](images/paste-42.png){fig-align="center" width="7cm"}

#### Memory Pool pattern

Prebuilt datapool for mutable data $\rightarrow$ Control over size

![](images/paste-43.png){fig-align="center" width="7cm"}

#### Compiler and Linker help

``` cpp
// Optimize for size 
gcc –Os <your file>.c
// Use link-time optimizations 
gcc -flto
// Use linker to remove unused code and data 
gcc -ffunction-sections -fdata-sections 
Link with --gc-sections
// Optimize for speed 
gcc –O2 <your file>.c 
gcc –O3 <your file>.c
```

#### Use better algorithms

.

![](images/paste-45.png)

#### Write better algorithms

.

![](images/paste-46.png)

#### Cache Data

.

![](images/paste-47.png){fig-align="center" width="7cm"}

#### More

-   Minimize data passing by **passing by reference**
-   **Datacompression** with Differencing (store difference of two values in sequence), or Run length encoding
-   Task notifications instead of queues
-   Limit scope of local variables
-   **Reduce Overhead** through removing layers

Engineering in the face of uncertainty:

1.  Use margins (e.g. RAM 200%-300%)
2.  Estimate early
3.  Check often

### Performance

## Preemptive Debugging

![](images/paste-39.png){fig-align="center" width="6cm" height="3.7cm"}

``` cpp
float squareRoot(float x) {
    // Require:
    // Failure equals happened before function gets called
    assert(x >= 0);
    y = ... ;
    // Ensure:
    // Failure equals error in this function
    assert((y*y) == x);
    return y;
}
```

With FreeRTOS `configAssert( x )` can be called. The behaviour is user dependent (standard `while(true);` $\rightarrow$ Fail-Safe.

``` cpp
/* Custom implementation */
void vAssertCalled( const char * pcFile, unsigned long ulLine ) {
 (void)pcFile; // unused
 (void)ulLine; // unused
 while (true); // LED, EEPROM,...
}
```

**D**on't **R**epeat **Y**ourself - **DRY**

![](images/paste-40.png)

::: callout-warning
## Don't do this

``` cpp
ASSERT(kbPress != 'j');
```

Avoid asserting **expected errors** $\rightarrow$ Handle directly in code

``` cpp
ASSERT(i++ < 5);
```

Avoid **Sideeffects**
:::

### Static Analysis

Happens **at compile-time**:

``` cpp
_Static_assert(BLINK_STACK_SIZE > configMINIMAL_STACK_SIZE, "Stack size too small");
```

Use a framework like [Frama-C](https://frama-c.com/):

``` cpp
/*@
    requires y > 0
    ensures \result > y
*/
int makeLarger(int y) {
    int x = y*2;
    return x;
}
```

## Security

![](images/paste-48.png)

::: callout-note
## C is not a "safe" language

Array overflow is not prevented, you could access the `state` variable in the following example:

![](images/paste-49.png){fig-align="center" width="6cm" height="3.5cm"}
:::

### Security failures are often design failures

Use the checklist **STRIDE** and design a architecture to avoid running into problems

-   **S**poofing

-   **T**ampering

-   **R**epudiation

-   **I**nformation Disclosure

-   **D**enial of Service

-   **E**levation of Privilige

![](images/paste-53.png){fig-align="center" width="8cm"}

### Evaluate Threads

This is time consuming $\rightarrow$ **in Projektmanagement beachten**

<https://emb3d.mitre.org/>

![](images/paste-54.png){fig-align="center" width="8cm"}

### Follow "secure" coding standards

<https://securecoding.cert.org/>

![](images/paste-50.png){fig-align="center" width="8cm" height="3.7cm"}

### Use static analysis to find problems

``` cpp
// Turn on all warnings 
gcc –Wall -Wextra <your file>.c
// Use static analyzer 
gcc –fanalyzer <your file>.c
```

### Consider exceptional CHILDREN

-   **C**omputation
-   **H**ardware
    -   Transient Faults
    -   Memory Corruption
-   **I**/O
    -   Running out of file space?
-   **L**ibrary
    -   Handle error returns
-   **D**ata input
    -   Buffer input overflows
    -   More / Less data than expected
-   **R**aces and deadlocks
-   **E**xternal user
    -   Wrong, Late, Other input
-   **N**ull pointer and memory

# Testing

Testing is for *Finding Bugs*, *Reduce risk to user **and** business*, *reduce development costs*, *keep code clean*, *improve performance* and to *verify that **requirements are met***. There are different test which can be performed:

-   *Unit Testing*: Verify behaviour of individual units (modules)
-   *Integration Testing*: Ensure that units work together as intended
-   *System Testing*: Test **end-to-end** functionality of application
-   *Acceptance Testing*: Verify that the requirements are met (whole system)
-   *Performance Testing*: Evalutate performance metrics (e.g. execution time)
-   *Smoke Testing*: Quick test to ensure major features are working

To make testing efficient, we implement automatic testing routines. They act as a **live** documentation. Allows for **refactoring with confidence**.

## Unit Test

A good test case checks **one behaviour** under **one condition**, this makes it easier to localise errors.

``` cpp
void test_single_element_in_single_element_out(void) {
    // Arrange: given buffer has a single element
    writeCircBuf(&buff, 11);
    // Act: when buffer is read
    uint32_t value = readCircBuf(&buff);
    // Assert: then the same value is returned
    TEST_ASSERT_EQUAL(11, value);
}
```

::: callout-note
## Testing Frameworks

-   [Unit Test Framework Unity](https://www.throwtheswitch.org/unity)
-   [Test Double Framework fff](https://github.com/meekrosoft/fff)
:::

### Unit Test with Collaborators

![](images/paste-13.png)

### Test Doubles

Implement test doubles through the fake function framework ([fff](https://github.com/meekrosoft/fff)). There are different variations of test doubles:

**Stub**: Specify a return value - *Arrange*

``` cpp
// Set single return value
i2c_hal_register_fake.return_val = true;
// Set return sequence
uint32_t myReturnVals[3] = { 3, 7, 9 };
SET_RETURN_SEQ(readCircBuf, myReturnVals, 3);
```

**Spy**: Capture Parameters - *Arrange* / *Assert*

``` cpp
// Arrange, e.g. get passed function
adc_hal_register(ADC_ID_1, dummy_callback);
void (*isr) (void) = ADCIntRegister_fake.arg2_val;
// Assert Parameter
TEST_ASSERT_EQUAL(3, ADCSequenceDataGet_fake.arg1_val);
```

**Mock**: Can act as a *Stub*, *Spy*, and much more (from fff). Implemented as follows:

``` cpp
// in some_mock.h
VALUE_FUNC(uint32_t *, initCircBuf, circBuf_t *, uint32_t);
VOID_FUNC(writeCircBuf, circBuf_t *, uint32_t);
```

**Fake**: Provide a custom fake function - *Arrange*

``` cpp
// Define Fake Function
int32_t ADCSequenceDataGet_fake_adc_value(uint32_t arg0, uint32_t arg1, uint32_t *arg2) {
    *arg2 = FAKE_ADC_VALUE;
    return 0;
}
// Apply Fake Function - Arrange
ADCSequenceDataGet_fake.custom_fake = ADCSequenceDataGet_fake_adc_value;
```

### Continuous Integration

*CI* is used to automate the integration of code changes. These are automated scripts running all the tests. This is usually implemented in the code hoster (e.g. *GitLab*) and is executed after every push. It also runs before every merge and **blocks a merge** if one of the tests fails.

## Higher Level Testing

Unit tests only verify small elements of a system in isolation.

### Automated Acceptance Testing

-   Verifys system requirements
-   Live documentation of high-level requirements
-   Understandify behaviour
-   Acceptance test pass $\rightarrow$ requirement met
-   Written by PM or QA ( $\approx$ customer)
-   Written in natural scripting language
-   Non-Technical stakeholder in the loop
-   Called: **B**ehaviour-**D**riven **D**evelopment **BDD**

### Automated System Tests

**Hardware Simulation**: Developed on PC, no need to know specific hardware implementation yet, limitations with hardware peripherals.

**Hardware Emulation**: Emulate processor on PC, needs resources for emulator. Tools: QUEMU

**Hardware in the Loop**: Runs on target, test scripts on a test enclosure to manipulate hardware, expensive setup. Tools: NI DAQ, Labview

![](images/paste-30.png){fig-align="center" width="8cm"}

### Manual Testing

Sometimes automated test setups are more expensive.

Manual testing can involve **user interaction**, **Debugger**, **direct Signal Probing** (Oscilloscope, Multimeter, Logic Analyzer).

## Test Driven Design TDD

![](images/paste-29.png)

Applying TDD through writing *unit tests* during development, benefits:

-   **Reduce Debug Time**: small feedback loop
-   **Courage to make changes**: tested code is changeable code
-   **Tests are Reliable**: high level of coverage
-   **Good Architecture**: Writing test implies decoupling

For each new unit:

1.  Come up with a **set of requirements**
2.  Generate a **rough test list**
3.  Implement unit by going through the list with **TDD**
4.  Tick off, remove, or add items to/from the list in the process

Use **ZOM** to come up with tests:

-   **Z**ero case(s): simplest scenario $\rightarrow$ build interface
-   **O**ne case: simplest scenario to transition from **Z**ero to **O**ne
-   **M**any cases: generalise design, each test case adds a scenario